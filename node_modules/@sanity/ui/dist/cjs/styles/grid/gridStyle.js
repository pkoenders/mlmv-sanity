"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gridStyle = void 0;
var helpers_1 = require("../helpers");
var GRID_AUTO_COLUMS = {
    auto: 'auto',
    min: 'min-content',
    max: 'max-content',
    fr: 'minmax(0, 1fr)',
};
var GRID_AUTO_ROWS = {
    auto: 'auto',
    min: 'min-content',
    max: 'max-content',
    fr: 'minmax(0, 1fr)',
};
function gridStyle(_a) {
    var autoCols = _a.autoCols, autoFlow = _a.autoFlow, autoRows = _a.autoRows;
    return [
        {
            '&&:not([hidden])': {
                display: 'grid',
            },
            gridAutoFlow: autoFlow,
            gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols],
            gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows],
        },
        responsiveGridColumnsStyle,
        responsiveGridRowsStyle,
        responsiveGridGapStyle,
    ];
}
exports.gridStyle = gridStyle;
function responsiveGridColumnsStyle(_a) {
    var columns = _a.columns, theme = _a.theme;
    return helpers_1.responsive(theme.sanity.media, helpers_1.getResponsiveProp(columns).map(function (val) { return ({
        gridTemplateColumns: val && "repeat(" + val + ", minmax(0, 1fr));",
    }); }));
}
function responsiveGridRowsStyle(_a) {
    var rows = _a.rows, theme = _a.theme;
    return helpers_1.responsive(theme.sanity.media, helpers_1.getResponsiveProp(rows).map(function (val) { return ({
        gridTemplateRows: val && "repeat(" + val + ", minmax(0, 1fr));",
    }); }));
}
function responsiveGridGapStyle(_a) {
    var gap = _a.gap, theme = _a.theme;
    return helpers_1.responsive(theme.sanity.media, helpers_1.getResponsiveProp(gap).map(function (spaceIndex) { return ({
        gridGap: gap ? helpers_1.rem(theme.sanity.space[spaceIndex]) : undefined,
    }); }));
}
//# sourceMappingURL=gridStyle.js.map